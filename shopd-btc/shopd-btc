#!/usr/bin/perl

# Copyright 2019 ChileBob
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files 
# (the "Software"), to deal in the Software without limitation the rights to use, copy, modify, merge, publish, distribute, sublicence
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITIES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Version 0.0.7-dev

use strict;

my $installdir = "$ENV{'HOME'}/.zatsuma";	# Default install directory
open (my $logfile, '>>', "$installdir/shopd-btc.log");

my $debug      = 2;				# debug level (0 = none, 1 = message only, 2 = message + var)

#####################################################################################################################################################################################################
# DONT CHANGE ANYTHING BELOW THIS LINE - EVERYTHING YOU NEED IS IN CONFIGURATION FILE shopd-btc.conf
#####################################################################################################################################################################################################

my @whitelist = (				# SAFETY CHECK - DO NOT ADD COMMANDS THAT CAN BE USED TO SEND FUNDS - USE 'bitcoin-cli help <command>' TO VERIFY!!!
	'getblockchaininfo',			# blockchain status/information
	'getnetworkinfo',			# network status/information
	'getnewaddress',			# generate new taddr
	'gettransaction',			# get transaction from txid
	'listreceivedbyaddress'			# list transactions received 
);

use IO::Socket::INET;													# network sockets
use JSON;														# general purpose JSON
use JSON::RPC::Client;	
use String::HexConvert ':all';												# used to decode memo field on zaddr transactions
use Data::Dumper;													# debugging output, can be deleted

my %config = ();													# config hash

my $json_socket;													# listening socket for JSON requests
my $client_socket;			
my $client_addr;
my $client_maxbytes = 10000;												# max bytes read from network socket

my $JSON = JSON->new->utf8;												# UTF8 encoding for JSON data
my %json = ();						
my $json;
my $json_rx;
my %json_tx = ();													# clear JSON vars
my $json_tx = '';

my $node_res;														# hashref from node query

&config_load("$ENV{'HOME'}/.bitcoin/bitcoin.conf");									# load bitcoind config
&config_load("$installdir/shopd-btc.conf");										# load local config

if ($ARGV[0] eq '-notify') {												# called by walletnotify
	&debug("INFO: new txid $ARGV[1]");
	&json_send($config{'shopip'}, $config{'shopport'}, &lookup_txid($ARGV[1]));
	exit;
}

while (!&node_command('getnetworkinfo') ){ 										# SAFETY CHECK - check bitcoind is running
	&debug("WARNING: bitcoind IS NOT RUNNING! Retrying in 60 seconds...");
	sleep(60);
}

if (&node_command('listreceivedbyaddress', [0, JSON::true] ) ){ 							# SAFETY CHECK - address must belong to this node
	if ( !grep { $config{'addr'} eq $_->{'address'} } @{$node_res->{'result'}} ) {
		&debug("WARNING! The address \'$config{'addr'}\' in shopd-btc.conf DOES NOT BELONG TO THIS NODE!");
		if (&node_command('getnewaddress' ) ) { 								# generate new address
			$config{'addr'} = $node_res->{'result'};
			open (my $fh, '>>', "$installdir/shopd-btc.conf") or die "Could not add new address to $installdir/shopd-btc.conf";		# add to confir
			say $fh "addr = \"$node_res->{'result'}\"\t\t\t\#New address generated by shopd-btc";
			close ($fh);
		}
		&debug("New address = \'$config{'addr'}\'");
	}
	else {
		&debug("OK! Using \'$config{'addr'}\'");
	}

}

$json_socket = new IO::Socket::INET (											# open listening network socket
	LocalHost => '127.0.0.1',
	LocalPort => $config{'port'}, 
	Proto => 'tcp',
	Listen => $config{'sockets'},
	Reuse => 1
);
$| = 1; 														# auto-flush on network socket
die "FATAL: Cannot create socket\n" unless $json_socket;								# die if we cant open a socket

&debug ("INFO: Starting daemon, listening on 127.0.0.1, port $config{'port'}, $config{'sockets'} sockets available");		# helpful startup message

while(1) { 														
 

	%json = ();													# clear JSON vars
	$json = '';
	$json_rx = '';
	%json_tx = ();													# clear JSON vars
	$json_tx = '';
 
	$client_socket = $json_socket->accept();									# accept connection

 	$client_addr = $client_socket->peerhost();									# get address of incoming connection
	if ( $config{'shopip'} != $client_socket->peerhost() ) {					
		&debug("WARNING: Suspect incoming connection $client_socket->peerhost(), expected from $config{'shopip'}");
	}

	$client_socket->recv($json_rx, $client_maxbytes);								# read request from client
 
	$json = eval { decode_json($json_rx) };										# decode JSON from proxy, eval wrapped so it wont die horribly when fed garbage
	if ($@) {
		&debug("######## SHOPD-BTC : GARBAGE REQUEST ########", $json);
	}
	else {
		$json = decode_json($json_rx);										# decode JSON request for real this time

		&debug("######## SHOPD-BTC : NEW REQUEST ########", $json);

		###############################################################################################################################################################################################
		if ($json->{'cmd'} eq 'status_get' ) {								# request node status

				if (&node_command('getnetworkinfo' ) ){ 						# get network details
					$json->{'version'} = $node_res->{'result'}->{'version'};			# bitcoind version
					$json->{'connections'} = $node_res->{'result'}->{'connections'};		# number of peers connected
				}
				if (&node_command('getblockchaininfo' ) ){ 						# get blockchain info
					$json->{'blocks'} = $node_res->{'result'}->{'blocks'};				# current blockcount
				}
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'config_get' ) {							# request config

			$json->{'addr'} = $config{'addr'};								# fixed address
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'order_new' ) {							# generate address/reference for a new order

			if (&node_command('getnewaddress')) { 							# generate new address
				$json->{'address'} = $node_res->{'result'};		
				$json->{'uri'} = "bitcoin:$node_res->{'result'}\?amount=$json->{'coinamount'}";	# generate uri
			}
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'check_conf' ) {							# lookup transaction confirmations given the txid (transparent or shielded)

				$json = &lookup_conf($json->{'txid'});
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'check_txid' ) {							# lookup transaction given the txid (transparent or shielded)

				$json = &lookup_txid($json->{'txid'});
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'check_address' ) {							# lookup transaction given the taddr		

			if (&node_command('listreceivedbyaddress', [ 0 ] ) ){ 						# get all receipts
				foreach my $rx ( @{ $node_res->{'result'} }) {						# step through results	
					if ($rx->{'address'} eq $json->{'cmd[address]'}) {
						$json->{'amount'} = $rx->{'amount'};					# amount
						$json->{'confirmations'} = $rx->{'confirmations'};			# confirmations
						$json->{'address'} = $json->{'cmd[address]'};				# address
					}
				}
			}
		}

		$json->{'updated'} = time;									# add a timestamp so shopd can cache things

		%json_tx = encode_json $json, { utf8 => 1};							# JSON encode response hash
		$client_socket->send(%json_tx);									# send it 

		&debug("######## RESPONSE ########", $json);
	}
}
$json_socket->close();												# we're done, hasta luego (as they say here in the colonies)
exit;														


#####################################################################################################################################################################################################
# Usage: &config_load( $filename );									Load/Reload config file

sub config_load {

	&debug("config_load($_[0])");

	$config{'updated'} = (stat("$_[0]"))[9];								# log the time so we can react to updates

	open (CONFIG, "$_[0]") || die ("Cant open $_[0]");							# load/parse the config file
	while (my $line = <CONFIG>) {
		chop($line);
		$line =~ s/\#.*//;										# strip comments
		my @conf = split('=', $line);
		$conf[0] =~ s/\s//g;										# strip whitespace from keyword
		$conf[1] =~ s/\"//g;										# strip opening/closing double quotes on values
		$conf[1] =~ s/^\s//g;										# strip leading whitespace on value
		$conf[1] =~ s/\s*$//g;										# strip trailing whitespace on value

		if ($conf[0]) {											# add to hash if keyword is valid
			$config{$conf[0]} = $conf[1];
		}
	}
	close (CONFIG);
}


#####################################################################################################################################################################################################
# Usage: &node_command( method, params);								Talk to the RPC server

sub node_command {
	
	&debug("node_command($_[0])");

	if ( grep(/$_[0]/, @whitelist) ) {									# confirm method is whitelisted

		my $client = new JSON::RPC::Client;

		$client->ua->credentials( "localhost:$config{'rpcport'}", 'jsonrpc', $config{'rpcuser'}, $config{'rpcpassword'} );	# rpc authentication 

		my $uri = "http://localhost:$config{'rpcport'}/";
		my $obj = { 'method' => $_[0], 'params' => @_[1] };
	
		my $result = $client->call( $uri, $obj );							# responses held in global hashref

		if ($result){				
			$node_res = { 'result' => $result->{'content'}->{'result'} };				# only return the juicy bits
			return(1);
		}
		else {												# failed connection (or node warming up)
			$node_res = { 'error' => 'bitcoind is not responding', 'errorcode' => -1 };
 			&debug("WARNING : node_command() : bitcoind is not responding", $result->{'content'}->{'result'});
			return(0);
		}
	}
	else {													# method is NOT WHITELISTED !!!!!
		$node_res = { 'error' => 'restricted', 'errorcode' => 1 };
		&debug("WARNING: node_command($_[0]) : RESTRICTED COMMAND !!!");
		return(0);	
	}
}

#####################################################################################################################################################################################################
# Usage: &json_send(ipaddr, port, query);								Send to shopd 
#
sub json_send {

	&debug("json_send($_[0], $_[1])", $_[2]);

	my $json_rx;
	my %json_tx = ( 'cmd[req]' => 'notify', 'cmd[coin]' => 'zec', 'cmd[data]' => $_[2] );			# this is how we talk to shopd, its ugly but works

	my $socket = IO::Socket::INET->new(PeerAddr => $_[0], PeerPort => $_[1], Proto => 'tcp');

	if (!$socket) {												# failed to connect, shopd down
		return(0);
	}
	else {
		my $json_tx = encode_json \%json_tx, { utf8 => 1};						# JSON encode request
		$socket->send($json_tx);									# send it 
		$socket->recv($json_rx, $client_maxbytes);							# read response
		$socket->close();										# close the socket
		return(decode_json($json_rx));									# return decoded response
	}
}

#####################################################################################################################################################################################################
# Usage: &lookup_conf (txid);										Get confirmations
#
sub lookup_conf {

	&debug("lookup_conf()", $_[0]);

	my $tx;

	if (&node_command('gettransaction', [ $_[0] ] ) ){ 							# lookup transaction
		$tx->{'confirmations'} = $node_res->{'result'}->{'confirmations'};				# found it
		return($tx);											# return confirmations
	}
	else {													# nope, return null
		return(0);
	}
}

#####################################################################################################################################################################################################
# Usage: &lookup_txid (txid);										Get details of transaction
#
sub lookup_txid {

	&debug("lookup_txid()", $_[0]);

	my $txid;

	if (&node_command('gettransaction', [ $_[0] ] ) ){ 							# lookup transaction
		$txid->{'confirmations'} = $node_res->{'result'}->{'confirmations'};	

		my $details = @{ $node_res->{'result'}->{'details'} };
		if ( $details > 0 ) {										# TADDR ('cos tx details were available)
			$txid->{'coin'} = 'BTC';
			foreach my $rx ( @{ $node_res->{'result'}->{'details'} }) {				# step through details, looking for receive 
				if ($rx->{'category'} eq 'receive') {
					$txid->{'address'} = $rx->{'address'};	
					$txid->{'amount'} = $rx->{'amount'};
				}
			}
		}
		$txid->{'txid'} = $_[0];									# append txid
	}
	&debug("lookup_txid()", $txid);
	return($txid);												# send back json
}


#####################################################################################################################################################################################################
# Usage: &debug(message, var);										Print debugging messages
#
sub debug {

	if ($debug > 0) {											# print the message (debug = 1)
		printf $logfile "$_[0]\n";
	}

	if ( ($_[1]) && ($debug > 1)) {										# print the var (debug = 2)
		print $logfile Dumper($_[1]);
	}
}


