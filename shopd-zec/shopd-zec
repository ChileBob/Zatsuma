#!/usr/bin/perl
# 
# Copyright 2019 ChileBob
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files 
# (the "Software"), to deal in the Software without limitation the rights to use, copy, modify, merge, publish, distribute, sublicence
# and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITIES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
# OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# Version 0.0.6-rc2

use strict;

my $installdir = "$ENV{'HOME'}";											# Default installation directory
my $debug = 1;														# debug level (0 = none, 1 = message, 2 = message + var)

#####################################################################################################################################################################################################
# DONT CHANGE ANYTHING BELOW THIS LINE - EVERYTHING YOU NEED IS IN CONFIGURATION FILE shopd-zec.conf
#####################################################################################################################################################################################################

my @whitelist = (				# SAFETY CHECK - DO NOT ADD COMMANDS THAT CAN BE USED TO SEND FUNDS - USE 'zcash-cli help <command>' TO VERIFY!!!
	'getinfo',				# basic network state/info					
	'getnewaddress',			# generate new taddr
	'gettransaction',			# get transaction from txid
	'listreceivedbyaddress',		# list taddr transactions
	'z_listreceivedbyaddress',		# list zaddr transactions
	'z_listaddresses',			# list zaddrs
	'z_getnewaddress'			# generate new zaddr
);

use utf8;
use Encode qw( encode_utf8 );
use IO::Socket::INET;													# network sockets
use JSON;														# general purpose JSON
use JSON::RPC::Client;	
use String::HexConvert ':all';												# used to decode memo field on zaddr transactions
use Data::Dumper;													# debugging output, can be deleted

my %config = ();													# config hash

my $json_socket;													# listening socket for JSON requests
my $client_socket;			
my $client_addr;
my $client_maxbytes = 10000;												# max bytes read from socket

my $JSON = JSON->new->utf8;												# UTF8 encoding for JSON data
my %json = ();						
my $json;
my $json_rx;
my %json_tx = ();													# clear JSON vars
my $json_tx = '';

my $node_res;														# hashref from node query

&config_load("$ENV{'HOME'}/.zcash/zcash.conf");										# load zcashd config
&config_load("$installdir/shopd-zec.conf");										# load local config

if ($ARGV[0] eq '-notify') {												# called by walletnotify
	&json_send($config{'shopip'}, $config{'shopport'}, &lookup_txid($ARGV[1]));
	exit;
}

while (!&node_command('getinfo') ){ 											# SAFETY CHECK - check zcashd is running
	&debug("WARNING! zcashd IS NOT RUNNING! Retrying in 60 seconds...");
	sleep(60);
}

if (&node_command('listreceivedbyaddress', [0, JSON::true] ) ){ 							# SAFETY CHECK - taddr must belong to this node
	if ( !grep { $config{'taddr'} eq $_->{'address'} } @{$node_res->{'result'}} ) {
		&debug("WARNING! The taddr \'$config{'taddr'}\' in shopd-zec.conf DOES NOT BELONG TO THIS NODE!");
		if (&node_command('getnewaddress' ) ){ 									# generate new taddr
			$config{'taddr'} = $node_res->{'result'};
			open (my $fh, '>>', "$installdir/shopd-zec.conf") or die "Could not add new taddr to $installdir/shopd-zec.conf";		# add to confir
			say $fh "taddr = \"$node_res->{'result'}\"\t\t\t\#New address generated by shopd-zec";
			close ($fh);
		}
		&debug("New taddr = \'$config{'taddr'}\'");
	}
	else {
		&debug("OK! Using \'$config{'taddr'}\'");
	}

}

if (&node_command('z_listaddresses' ) ){ 										# SAFETY CHECK - zaddr must belong to this node 
	if ( !grep(/$config{'zaddr'}/, @{$node_res->{'result'}}) ) {
		&debug("WARNING! The zaddr \'$config{'zaddr'}\' in shopd-zec.conf DOES NOT BELONG TO THIS NODE!");
		if (&node_command('z_getnewaddress' ) ){ 									# generate new taddr
			$config{'zaddr'} = $node_res->{'result'};
			open (my $fh, '>>', "$installdir/shopd-zec.conf") or die "Could not add new zaddr to $installdir/shopd-zec.conf";	# add to confir
			say $fh "zaddr = \"$node_res->{'result'}\"\t\t\t\#New address generated by shopd-zec";
			close ($fh);
		}
		&debug("New zaddr = \'$config{'zaddr'}\'");
	}
	else {
		&debug("OK! Using \'$config{'zaddr'}\'");
	}
}


$json_socket = new IO::Socket::INET (											# open listening network socket
	LocalHost => '127.0.0.1',
	LocalPort => $config{'port'}, 
	Proto => 'tcp',
	Listen => $config{'sockets'},
	Reuse => 1
);
$| = 1; 														# auto-flush on network socket
die "FATAL: Cannot create socket\n" unless $json_socket;								# die if we cant open a socket

print "Starting daemon, listening on 127.0.0.1, port $config{'port'}, $config{'sockets'} sockets available\n";		# helpful startup message

while(1) { 														
 

	%json = ();													# clear JSON vars
	$json = '';
	$json_rx = '';
	%json_tx = ();													# clear JSON vars
	$json_tx = '';
 
	$client_socket = $json_socket->accept();									# accept connection

	print "\033[2J";												# clear screen
	print "\033[0;0H";												# move to top of screen
	
 	$client_addr = $client_socket->peerhost();									# Get address of incoming connection
	if ( $config{'shopip'} != $client_socket->peerhost() ) {					
		&debug("WARNING! Suspect incoming connection $client_socket->peerhost(), expected from $config{'shopip'}");
	}

	$client_socket->recv($json_rx, $client_maxbytes);								# read request from client
 
	$json = eval { decode_json($json_rx) };										# decode JSON from proxy, eval wrapped so it wont die horribly when fed garbage
	if ($@) {
		&debug("######## SHOPD-ZEC : GARBAGE REQUEST ########", $json);
	}
	else {
		$json = decode_json($json_rx);										# decode JSON request for real this time

		&debug("######## SHOPD-ZEC : NEW REQUEST ########", $json);

		###############################################################################################################################################################################################
		if ($json->{'cmd'} eq 'status_get' ) {								# request node status

				if (&node_command('getinfo' ) ){ 							# basic node information
					$json->{'version'} = $node_res->{'result'}->{'version'};			# zcashd version
					$json->{'blocks'} = $node_res->{'result'}->{'blocks'};				# current blockcount
					$json->{'connections'} = $node_res->{'result'}->{'connections'};		# number of peers connected
				}
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'config_get' ) {							# request config

			$json->{'taddr'} = $config{'taddr'};								# fixed transparent address
			$json->{'zaddr'} = $config{'zaddr'};								# fixed shielded address
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'order_new' ) {							# generate address/reference for a new order

			if ($json->{'coin'} eq 'ZECT') {								# transparent transaction
				if (&node_command('getnewaddress')) { 							# generate new address
					$json->{'address'} = $node_res->{'result'};		
					$json->{'uri'} = "zcash:$node_res->{'result'}\?amount=$json->{'coinamount'}";	# generate uri
				}
			}
			elsif ($json->{'coin'} eq 'ZECZ') {								# shielded transaction
				$json->{'address'} = $config{'zaddr'};							# use zaddr from config
 				$json->{'uri'} = "zcash:$config{'zaddr'}?amt=$json->{'coinamount'}&memo=Ref:$json->{'ordernumber'} - $json->{'shopname'}";	# generate uri
			}
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'check_conf' ) {							# lookup transaction confirmations given the txid (transparent or shielded)

			if ($json->{'txid'}) {										# check we have a non-null txid
				$json = &lookup_conf($json->{'txid'});
			}
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'check_txid' ) {							# lookup transaction given the txid (transparent or shielded)

				$json = &lookup_txid($json->{'txid'});
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'check_address' ) {							# lookup transaction given the taddr		

			if (&node_command('listreceivedbyaddress', [ 0 ] ) ){ 						# get all taddr receipts
				foreach my $rx ( @{ $node_res->{'result'} }) {						# step through results	
					if ($rx->{'address'} eq $json->{'cmd[address]'}) {
						$json->{'amount'} = $rx->{'amount'};					# amount
						$json->{'confirmations'} = $rx->{'confirmations'};			# confirmations
						$json->{'address'} = $json->{'cmd[address]'};				# address
					}
				}
			}
		}

		###############################################################################################################################################################################################
		elsif ($json->{'cmd'} eq 'check_ordernumber' ) {						# lookup transaction given a zaddr & order number

			if (&node_command('z_listreceivedbyaddress', [ $json->{'cmd[zaddr]'}, 0 ] )) { 			# get all zaddr receipts (could be lots!)
				foreach my $rx ( @{ $node_res->{'result'} }) {						# step through & decode the memos
					my $ordernumber = substr(hex_to_ascii($rx->{'memo'}),4,8);			# decode memo from hex to ascii
					if ($ordernumber eq $json->{'cmd[ordernumber]'}) {
						$json->{'ordernumber'} = $json->{'cmd[ordernumber]'};			# ordernumber
						$json->{'amount'} = $rx->{'amount'};					# amount

						&node_command('gettransaction', [ $rx->{'txid'} ] );			# confirmations
						$json->{'confirmations'} = $node_res->{'result'}->{'confirmations'};
						$json->{'txid'} = $rx->{'txid'};
					}
				}
			}
		}

		$json->{'updated'} = time;									# add a timestamp so shopd can cache things

		%json_tx = encode_json $json, { utf8 => 1};							# JSON encode response hash
		$client_socket->send(%json_tx);									# send it 

		&debug("######## RESPONSE ########", $json);
	}
}
$json_socket->close();												# we're done, hasta luego (as they say here in the colonies)
exit;														


#####################################################################################################################################################################################################
# Usage: &config_load( $filename );									Load/Reload config file

sub config_load {

	&debug("config_load($_[0])");

	$config{'updated'} = (stat("$_[0]"))[9];								# log the time so we can react to updates

	open (CONFIG, "$_[0]") || die ("Cant open $_[0]");							# load/parse the config file
	while (my $line = <CONFIG>) {
		chop($line);
		$line =~ s/\#.*//;										# strip comments
		my @conf = split('=', $line);
		$conf[0] =~ s/\s//g;										# strip whitespace from keyword
		$conf[1] =~ s/\"//g;										# strip opening/closing double quotes on values
		$conf[1] =~ s/^\s//g;										# strip leading whitespace on value
		$conf[1] =~ s/\s*$//g;										# strip trailing whitespace on value
		if ($conf[0]) {											# add to hash if keyword is valid
			$config{$conf[0]} = $conf[1];
		}
	}
	close (CONFIG);
}


#####################################################################################################################################################################################################
# Usage: &node_command( method, params);								Talk to the RPC server

sub node_command {
	
	&debug("node_command($_[0])");

	if ( grep(/$_[0]/, @whitelist) ) {									# confirm method is whitelisted

		my $client = new JSON::RPC::Client;

		$client->ua->credentials( "localhost:$config{'rpcport'}", 'jsonrpc', $config{'rpcuser'}, $config{'rpcpassword'} );	# rpc authentication 

		my $uri = 'http://localhost:8232/';
		my $obj = { 'method' => $_[0], 'params' => @_[1] };
	
		my $result = $client->call( $uri, $obj );							# responses held in global hashref

		if ($result){				
			$node_res = { 'result' => $result->{'content'}->{'result'} };				# only return the juicy bits
			return(1);
		}
		else {												# failed connection (or node warming up)
			$node_res = { 'error' => 'zcashd is not responding', 'errorcode' => -1 };
			&debug("WARNING : node_command() : zcashd is not responding", $result->{'content'}->{'result'});
			return(0);
		}
	}
	else {													# method is NOT WHITELISTED !!!!!
		$node_res = { 'error' => 'restricted', 'errorcode' => 1 };
		&debug("WARNING: node_command($_[0]) : RESTRICTED COMMAND !!!");
		return(0);	
	}
}

#####################################################################################################################################################################################################
# Usage: &json_send(ipaddr, port, query);								Send to shopd 
#
sub json_send {

	&debug("json_send($_[0], $_[1])", $_[2]);

	my $json_rx;
	my %json_tx = ( 'cmd[req]' => 'notify', 'cmd[coin]' => 'zec', 'cmd[data]' => $_[2] );			# this is how we talk to shopd, its ugly but works

	my $socket = IO::Socket::INET->new(PeerAddr => $_[0], PeerPort => $_[1], Proto => 'tcp');

	if (!$socket) {												# failed to connect, shopd down
		return(0);
	}
	else {
		my $json_tx = encode_json \%json_tx;								# JSON encode request
		$socket->send($json_tx);									# send it 
		$socket->recv($json_rx, $client_maxbytes);							# read response
		$socket->close();										# close the socket
		return(decode_json($json_rx));									# return decoded response
	}
}

#####################################################################################################################################################################################################
# Usage: &lookup_conf (txid);										Get confirmations
#
sub lookup_conf {

	&debug("lookup_conf()", $_[0]);

	my $tx;

	if (&node_command('gettransaction', [ $_[0] ] ) ){ 							# lookup transaction
		$tx->{'confirmations'} = $node_res->{'result'}->{'confirmations'};				# found it
		return($tx);											# return confirmations
	}
	else {													# nope, return null
		return(0);
	}
}

#####################################################################################################################################################################################################
# Usage: &lookup_txid (txid);										Get details of transaction
#
sub lookup_txid {

	&debug("lookup_txid()", $_[0]);

	my $txid;

	if (&node_command('gettransaction', [ $_[0] ] ) ){ 							# lookup transaction
		$txid->{'confirmations'} = $node_res->{'result'}->{'confirmations'};	

		my $details = @{ $node_res->{'result'}->{'details'} };
		if ( $details > 0 ) {										# TADDR ('cos tx details were available)
			$txid->{'coin'} = 'ZECT';
			foreach my $rx ( @{ $node_res->{'result'}->{'details'} }) {				# step through details, looking for receive 
				if ($rx->{'category'} eq 'receive') {
					$txid->{'address'} = $rx->{'address'};	
					$txid->{'amount'} = $rx->{'amount'};
				}
			}
		}
		else {												# ZADDR ('cos no tx details available)
			$txid->{'coin'} = 'ZECZ';
			&node_command('z_listaddresses', [ JSON::true ] ); 						# get list all zaddrs (including watch only)
			my @zaddr = @{ $node_res->{'result'} };

			foreach my $zaddr (@zaddr) {									# step through all zaddrs
				if (&node_command('z_listreceivedbyaddress', [ $zaddr, 0 ] )) { 			# get list of receipts for each zaddr
					foreach my $rx ( @{ $node_res->{'result'} }) {					# step through all receipts, look for txid
						if ($rx->{'txid'} eq $_[0]) {						
							$txid->{'address'} = $zaddr;					# log receiving zaddr

							$txid->{'memo'} = pack("H*",$rx->{'memo'});			# decode the memo (hex encoded)
							$txid->{'memo'} =~ s/\0*.$//g;					# strip null char padding
						}
					}
				}
			}
		}

		$txid->{'txid'} = $_[0];									# append txid
	}
	return($txid);												# send back json
}


#####################################################################################################################################################################################################
# Usage: &debug(message, var);										Print debugging messages
#
sub debug {

	if ($debug > 0) {											# print the message (debug = 1)
		print "DEBUG : $_[0]\n";
	}

	if ( ($_[1]) && ($debug > 1)) {										# print the var (debug = 2)
		print Dumper $_[1];
	}
}


